#ifndef GAGGLED_EVENTS_SERVER_H_INCLUDED
#define GAGGLED_EVENTS_SERVER_H_INCLUDED

/* Auto-Generated by RPG. Don't edit this unless you really know what you're up to. No, really. */

#include <stdint.h>
#include <stdexcept>
#include <vector>
#include <string>
#include <zmq.hpp>
#include "rpgbase.hpp"

namespace gaggled_events_server {

    const uint32_t WIRE_VERSION = 9235;
    const uint32_t FNUM_STATECHANGE = 1;

    class BadMessage : public std::exception {
    public:
     // functions
     // members
    };

    class StateChange {
    public:
     // functions
     // members
      std::string down_type;
      uint8_t during_shutdown;
      std::string program;
      uint8_t up;
    };

    class gaggled_events : public rpgbase::RPGService {
    public:
     // functions
      uint8_t decode_uint8_t (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        uint8_t ret;
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_uint8_t (uint8_t* outbuf, uint32_t* buf_offset, uint8_t obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
      }
      uint32_t decode_uint32_t (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        uint32_t ret;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          ret = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_uint32_t (uint8_t* outbuf, uint32_t* buf_offset, uint32_t obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((obj >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((obj >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((obj >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
      }
      StateChange decode_StateChange (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        char vchar_buf[256];
        uint32_t vchar_size;
        StateChange ret;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((vchar_size > 4)) {
          throw BadMessage();
        }
        memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
        vchar_buf[vchar_size] = 0;
        ret.down_type = std::string(vchar_buf);
        (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret.during_shutdown = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((vchar_size > 255)) {
          throw BadMessage();
        }
        memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
        vchar_buf[vchar_size] = 0;
        ret.program = std::string(vchar_buf);
        (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret.up = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_StateChange (uint8_t* outbuf, uint32_t* buf_offset, StateChange& obj) {
        uint32_t lencache=((&(obj.down_type)))->length();
        if ((lencache > 4)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        memcpy(((*(buf_offset)) + outbuf), ((&(obj.down_type)))->c_str(), lencache);
        (*(buf_offset)) = ((*(buf_offset)) + lencache);
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj.during_shutdown >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
        uint32_t lencache_1=((&(obj.program)))->length();
        if ((lencache_1 > 255)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache_1 >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache_1 >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache_1 >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache_1 >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        memcpy(((*(buf_offset)) + outbuf), ((&(obj.program)))->c_str(), lencache_1);
        (*(buf_offset)) = ((*(buf_offset)) + lencache_1);
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj.up >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
      }
      ~gaggled_events () {
        delete sock;
        if (ctx_created) {
          delete ctx;
        }
      }
      gaggled_events (const char* url, uint32_t threads=1, gaggled_events* compatriot=NULL) {
        if ((compatriot == NULL)) {
          ctx = new zmq::context_t(threads);
          ctx_created = true;
        } else {
          ctx = (*(compatriot)).ctx;
          ctx_created = false;
        }
        sock = new zmq::socket_t((*(ctx)), ZMQ_PUB);
        (sock)->bind(url);
      }
      void zmq_sendbuf () {
        zmq::message_t out_req(msgbuf_s);
        memcpy(((&(out_req)))->data(), msgbuf, msgbuf_s);
        (sock)->send(out_req);
      }
      void pub_statechange (StateChange& req) {
        msgbuf_s = 0;
        (this)->encode_uint32_t(msgbuf, (&(msgbuf_s)), WIRE_VERSION);
        (this)->encode_uint32_t(msgbuf, (&(msgbuf_s)), FNUM_STATECHANGE);
        (this)->encode_StateChange(msgbuf, (&(msgbuf_s)), req);
        (this)->zmq_sendbuf();
      }
     // members
      bool ctx_created;
      uint8_t msgbuf[277];
      uint32_t msgbuf_s;
    };
}
#endif