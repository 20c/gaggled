#ifndef GAGGLED_EVENTS_CLIENT_H_INCLUDED
#define GAGGLED_EVENTS_CLIENT_H_INCLUDED

/* Auto-Generated by RPG. Don't edit this unless you really know what you're up to. No, really. */

#include <stdint.h>
#include <stdexcept>
#include <vector>
#include <string>
#include <zmq.hpp>
#include "rpgbase.hpp"

namespace gaggled_events_client {

    const uint32_t WIRE_VERSION = 9237;
    const uint32_t FNUM_DUMPED = 1;
    const uint32_t FNUM_STATECHANGE = 2;

    class BadMessage : public std::exception {
    public:
     // functions
     // members
    };

    class ProgramState {
    public:
     // functions
     // members
      uint8_t dependencies_satisfied;
      std::string down_type;
      uint8_t during_shutdown;
      uint8_t is_operator_shutdown;
      int64_t pid;
      std::string program;
      uint64_t state_sequence;
      uint8_t up;
      uint64_t uptime_ms;
    };

    template<typename implementation_child_type>
    class gaggled_events : public rpgbase::RPGService {
    public:
     // functions
      int32_t decode_int32_t (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        int32_t ret;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          ret = ((((int32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((int32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((int32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((int32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_int32_t (uint8_t* outbuf, uint32_t* buf_offset, int32_t obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((obj >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((obj >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((obj >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
      }
      uint8_t decode_uint8_t (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        uint8_t ret;
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_uint8_t (uint8_t* outbuf, uint32_t* buf_offset, uint8_t obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
      }
      uint32_t decode_uint32_t (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        uint32_t ret;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          ret = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_uint32_t (uint8_t* outbuf, uint32_t* buf_offset, uint32_t obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((obj >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((obj >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((obj >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
      }
      ProgramState decode_ProgramState (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        char vchar_buf[256];
        uint32_t vchar_size;
        ProgramState ret;
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret.dependencies_satisfied = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((vchar_size > 4)) {
          throw BadMessage();
        }
        memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
        vchar_buf[vchar_size] = 0;
        ret.down_type = std::string(vchar_buf);
        (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret.during_shutdown = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret.is_operator_shutdown = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        if ((buf_size >= ((*(buf_offset)) + 8))) {
          ret.pid = ((((int64_t)(inbuf[((*(buf_offset)) + 0)])) << 56) + ((((int64_t)(inbuf[((*(buf_offset)) + 1)])) << 48) + ((((int64_t)(inbuf[((*(buf_offset)) + 2)])) << 40) + ((((int64_t)(inbuf[((*(buf_offset)) + 3)])) << 32) + ((((int64_t)(inbuf[((*(buf_offset)) + 4)])) << 24) + ((((int64_t)(inbuf[((*(buf_offset)) + 5)])) << 16) + ((((int64_t)(inbuf[((*(buf_offset)) + 6)])) << 8) + (((int64_t)(inbuf[((*(buf_offset)) + 7)])) << 0))))))));
          (*(buf_offset)) = ((*(buf_offset)) + 8);
        } else {
          throw BadMessage();
        }
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((vchar_size > 255)) {
          throw BadMessage();
        }
        memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
        vchar_buf[vchar_size] = 0;
        ret.program = std::string(vchar_buf);
        (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
        if ((buf_size >= ((*(buf_offset)) + 8))) {
          ret.state_sequence = ((((uint64_t)(inbuf[((*(buf_offset)) + 0)])) << 56) + ((((uint64_t)(inbuf[((*(buf_offset)) + 1)])) << 48) + ((((uint64_t)(inbuf[((*(buf_offset)) + 2)])) << 40) + ((((uint64_t)(inbuf[((*(buf_offset)) + 3)])) << 32) + ((((uint64_t)(inbuf[((*(buf_offset)) + 4)])) << 24) + ((((uint64_t)(inbuf[((*(buf_offset)) + 5)])) << 16) + ((((uint64_t)(inbuf[((*(buf_offset)) + 6)])) << 8) + (((uint64_t)(inbuf[((*(buf_offset)) + 7)])) << 0))))))));
          (*(buf_offset)) = ((*(buf_offset)) + 8);
        } else {
          throw BadMessage();
        }
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret.up = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        if ((buf_size >= ((*(buf_offset)) + 8))) {
          ret.uptime_ms = ((((uint64_t)(inbuf[((*(buf_offset)) + 0)])) << 56) + ((((uint64_t)(inbuf[((*(buf_offset)) + 1)])) << 48) + ((((uint64_t)(inbuf[((*(buf_offset)) + 2)])) << 40) + ((((uint64_t)(inbuf[((*(buf_offset)) + 3)])) << 32) + ((((uint64_t)(inbuf[((*(buf_offset)) + 4)])) << 24) + ((((uint64_t)(inbuf[((*(buf_offset)) + 5)])) << 16) + ((((uint64_t)(inbuf[((*(buf_offset)) + 6)])) << 8) + (((uint64_t)(inbuf[((*(buf_offset)) + 7)])) << 0))))))));
          (*(buf_offset)) = ((*(buf_offset)) + 8);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_ProgramState (uint8_t* outbuf, uint32_t* buf_offset, ProgramState& obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj.dependencies_satisfied >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
        uint32_t lencache=((&(obj.down_type)))->length();
        if ((lencache > 4)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        memcpy(((*(buf_offset)) + outbuf), ((&(obj.down_type)))->c_str(), lencache);
        (*(buf_offset)) = ((*(buf_offset)) + lencache);
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj.during_shutdown >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj.is_operator_shutdown >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj.pid >> 56) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((obj.pid >> 48) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((obj.pid >> 40) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((obj.pid >> 32) & 255)));
        outbuf[((*(buf_offset)) + 4)] = ((uint8_t)(((obj.pid >> 24) & 255)));
        outbuf[((*(buf_offset)) + 5)] = ((uint8_t)(((obj.pid >> 16) & 255)));
        outbuf[((*(buf_offset)) + 6)] = ((uint8_t)(((obj.pid >> 8) & 255)));
        outbuf[((*(buf_offset)) + 7)] = ((uint8_t)(((obj.pid >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 8);
        uint32_t lencache_1=((&(obj.program)))->length();
        if ((lencache_1 > 255)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache_1 >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache_1 >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache_1 >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache_1 >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        memcpy(((*(buf_offset)) + outbuf), ((&(obj.program)))->c_str(), lencache_1);
        (*(buf_offset)) = ((*(buf_offset)) + lencache_1);
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj.state_sequence >> 56) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((obj.state_sequence >> 48) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((obj.state_sequence >> 40) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((obj.state_sequence >> 32) & 255)));
        outbuf[((*(buf_offset)) + 4)] = ((uint8_t)(((obj.state_sequence >> 24) & 255)));
        outbuf[((*(buf_offset)) + 5)] = ((uint8_t)(((obj.state_sequence >> 16) & 255)));
        outbuf[((*(buf_offset)) + 6)] = ((uint8_t)(((obj.state_sequence >> 8) & 255)));
        outbuf[((*(buf_offset)) + 7)] = ((uint8_t)(((obj.state_sequence >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 8);
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj.up >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj.uptime_ms >> 56) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((obj.uptime_ms >> 48) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((obj.uptime_ms >> 40) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((obj.uptime_ms >> 32) & 255)));
        outbuf[((*(buf_offset)) + 4)] = ((uint8_t)(((obj.uptime_ms >> 24) & 255)));
        outbuf[((*(buf_offset)) + 5)] = ((uint8_t)(((obj.uptime_ms >> 16) & 255)));
        outbuf[((*(buf_offset)) + 6)] = ((uint8_t)(((obj.uptime_ms >> 8) & 255)));
        outbuf[((*(buf_offset)) + 7)] = ((uint8_t)(((obj.uptime_ms >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 8);
      }
      void recv_message (uint8_t* inbuf, uint32_t buf_size) {
        uint32_t decode_offset=0;
        uint32_t wv=(this)->decode_uint32_t(inbuf, (&(decode_offset)), buf_size);
        if ((wv != WIRE_VERSION)) {
          throw BadMessage();
        }
        uint32_t fnumber=(this)->decode_uint32_t(inbuf, (&(decode_offset)), buf_size);
        switch (fnumber) {
          case FNUM_DUMPED:
          {
            int32_t request_1;
            request_1 = (this)->decode_int32_t(inbuf, (&(decode_offset)), buf_size);
            try {
              (static_cast<implementation_child_type*>(this))->handle_dumped(request_1);
            } catch (...) {
            }
            break;
          }
          case FNUM_STATECHANGE:
          {
            ProgramState request_2;
            request_2 = (this)->decode_ProgramState(inbuf, (&(decode_offset)), buf_size);
            try {
              (static_cast<implementation_child_type*>(this))->handle_statechange(request_2);
            } catch (...) {
            }
            break;
          }
        }
      }
      void handle_dumped (int32_t req) {
      }
      void handle_statechange (ProgramState& req) {
      }
      ~gaggled_events () {
        delete sock;
        if (ctx_created) {
          delete ctx;
        }
      }
      gaggled_events (const char* url, uint32_t threads=1, gaggled_events* compatriot=NULL) {
        if ((compatriot == NULL)) {
          ctx = new zmq::context_t(threads);
          ctx_created = true;
        } else {
          ctx = (*(compatriot)).ctx;
          ctx_created = false;
        }
        sock = new zmq::socket_t((*(ctx)), ZMQ_SUB);
        (sock)->connect(url);
        (sock)->setsockopt(ZMQ_SUBSCRIBE, "", 0);
        pollitem.socket = (*(sock));
        pollitem.events = ZMQ_POLLIN;
      }
      void run_once (long timeout=0) {
        uint32_t busy=0;
        try {
          busy = zmq::poll((&(pollitem)), 1, timeout);
        } catch (zmq::error_t& ze) {
          return;
        }
        if ((busy > 0)) {
          (this)->run_once_bare();
        }
      }
      void run_once_bare () {
        zmq::message_t req;
        (sock)->recv((&(req)));
        (this)->recv_message(((uint8_t*)(((&(req)))->data())), ((&(req)))->size());
      }
     // members
      bool ctx_created;
      uint8_t msgbuf[303];
      uint32_t msgbuf_s;
    };
}
#endif