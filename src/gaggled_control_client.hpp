#ifndef GAGGLED_CONTROL_CLIENT_H_INCLUDED
#define GAGGLED_CONTROL_CLIENT_H_INCLUDED

/* Auto-Generated by RPG. Don't edit this unless you really know what you're up to. No, really. */

#include <stdint.h>
#include <stdexcept>
#include <vector>
#include <string>
#include <zmq.hpp>
#include "rpgbase.hpp"

namespace gaggled_control_client {

    const uint8_t ST_AFFIRM = 0;
    const uint8_t ST_BADMSG = 1;
    const uint8_t ST_FAILED = 2;
    const uint32_t WIRE_VERSION = 5235;
    const uint32_t FNUM_GETSTATE = 1;
    const uint32_t FNUM_START = 2;
    const uint32_t FNUM_STOP = 3;

    class ServerBadMessage : public std::exception {
    public:
     // functions
     // members
    };

    class ServerException : public std::exception {
    public:
     // functions
     // members
    };

    class ServerTimeout : public std::exception {
    public:
     // functions
     // members
    };

    class BadMessage : public std::exception {
    public:
     // functions
     // members
    };

    class ProgramStates {
    public:
     // functions
     // members
      std::vector<std::string> down;
      std::vector<std::string> up;
    };

    class gaggled_control : public rpgbase::RPGService {
    public:
     // functions
      uint32_t decode_uint32_t (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        uint32_t ret;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          ret = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_uint32_t (uint8_t* outbuf, uint32_t* buf_offset, uint32_t obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((obj >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((obj >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((obj >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
      }
      uint8_t decode_uint8_t (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        uint8_t ret;
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_uint8_t (uint8_t* outbuf, uint32_t* buf_offset, uint8_t obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
      }
      std::string decode_progname (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        char vchar_buf[256];
        uint32_t vchar_size;
        std::string ret;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((vchar_size > 255)) {
          throw BadMessage();
        }
        memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
        vchar_buf[vchar_size] = 0;
        ret = std::string(vchar_buf);
        (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
        return ret;
      }
      void encode_progname (uint8_t* outbuf, uint32_t* buf_offset, std::string obj) {
        uint32_t lencache=((&(obj)))->length();
        if ((lencache > 255)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        memcpy(((*(buf_offset)) + outbuf), ((&(obj)))->c_str(), lencache);
        (*(buf_offset)) = ((*(buf_offset)) + lencache);
      }
      ProgramStates decode_ProgramStates (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        char vchar_buf[256];
        uint32_t vchar_size;
        ProgramStates ret;
        uint32_t blsize;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          blsize = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((blsize > 64)) {
          throw BadMessage();
        }
        for (uint32_t blidx=0; (blidx < blsize); blidx = (blidx + 1)) {
          std::string rd;
          if ((buf_size >= ((*(buf_offset)) + 4))) {
            vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
            (*(buf_offset)) = ((*(buf_offset)) + 4);
          } else {
            throw BadMessage();
          }
          if ((vchar_size > 255)) {
            throw BadMessage();
          }
          memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
          vchar_buf[vchar_size] = 0;
          rd = std::string(vchar_buf);
          (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
          ((&(ret.down)))->push_back(rd);
        }
        uint32_t blsize_1;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          blsize_1 = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((blsize_1 > 64)) {
          throw BadMessage();
        }
        for (uint32_t blidx_1=0; (blidx_1 < blsize_1); blidx_1 = (blidx_1 + 1)) {
          std::string rd_1;
          if ((buf_size >= ((*(buf_offset)) + 4))) {
            vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
            (*(buf_offset)) = ((*(buf_offset)) + 4);
          } else {
            throw BadMessage();
          }
          if ((vchar_size > 255)) {
            throw BadMessage();
          }
          memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
          vchar_buf[vchar_size] = 0;
          rd_1 = std::string(vchar_buf);
          (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
          ((&(ret.up)))->push_back(rd_1);
        }
        return ret;
      }
      void encode_ProgramStates (uint8_t* outbuf, uint32_t* buf_offset, ProgramStates& obj) {
        uint32_t listsize=((&(obj.down)))->size();
        if ((listsize > 64)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((listsize >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((listsize >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((listsize >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((listsize >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        for (uint32_t listoffset=0; (listoffset < listsize); listoffset = (listoffset + 1)) {
          uint32_t lencache=((&(obj.down[listoffset])))->length();
          if ((lencache > 255)) {
            throw BadMessage();
          }
          outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache >> 24) & 255)));
          outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache >> 16) & 255)));
          outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache >> 8) & 255)));
          outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache >> 0) & 255)));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
          memcpy(((*(buf_offset)) + outbuf), ((&(obj.down[listoffset])))->c_str(), lencache);
          (*(buf_offset)) = ((*(buf_offset)) + lencache);
        }
        uint32_t listsize_1=((&(obj.up)))->size();
        if ((listsize_1 > 64)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((listsize_1 >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((listsize_1 >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((listsize_1 >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((listsize_1 >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        for (uint32_t listoffset_1=0; (listoffset_1 < listsize_1); listoffset_1 = (listoffset_1 + 1)) {
          uint32_t lencache_1=((&(obj.up[listoffset_1])))->length();
          if ((lencache_1 > 255)) {
            throw BadMessage();
          }
          outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache_1 >> 24) & 255)));
          outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache_1 >> 16) & 255)));
          outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache_1 >> 8) & 255)));
          outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache_1 >> 0) & 255)));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
          memcpy(((*(buf_offset)) + outbuf), ((&(obj.up[listoffset_1])))->c_str(), lencache_1);
          (*(buf_offset)) = ((*(buf_offset)) + lencache_1);
        }
      }
      ~gaggled_control () {
        delete sock;
        if (ctx_created) {
          delete ctx;
        }
      }
      gaggled_control (const char* url, uint32_t threads=1, gaggled_control* compatriot=NULL) {
        if ((compatriot == NULL)) {
          ctx = new zmq::context_t(threads);
          ctx_created = true;
        } else {
          ctx = (*(compatriot)).ctx;
          ctx_created = false;
        }
        sock = new zmq::socket_t((*(ctx)), ZMQ_REQ);
        (sock)->connect(url);
      }
      void zmq_reqrep (zmq::message_t* respmsg_ptr) {
        zmq::message_t out_req(msgbuf_s);
        memcpy(((&(out_req)))->data(), msgbuf, msgbuf_s);
        (sock)->send(out_req);
        (sock)->recv(respmsg_ptr);
      }
      ProgramStates call_getstate (uint8_t req) {
        msgbuf_s = 0;
        (this)->encode_uint32_t(msgbuf, (&(msgbuf_s)), WIRE_VERSION);
        (this)->encode_uint32_t(msgbuf, (&(msgbuf_s)), FNUM_GETSTATE);
        (this)->encode_uint8_t(msgbuf, (&(msgbuf_s)), req);
        zmq::message_t response;
        (this)->zmq_reqrep((&(response)));
        uint8_t* inbound_buf=((uint8_t*)(((&(response)))->data()));
        uint32_t inbound_bsize=((&(response)))->size();
        uint8_t remote_rcode;
        uint32_t response_offset=0;
        uint32_t wv=(this)->decode_uint32_t(inbound_buf, (&(response_offset)), inbound_bsize);
        if ((wv != WIRE_VERSION)) {
          throw BadMessage();
        }
        remote_rcode = (this)->decode_uint8_t(inbound_buf, (&(response_offset)), inbound_bsize);
        if ((remote_rcode != ST_AFFIRM)) {
          switch (remote_rcode) {
            case (ST_BADMSG):
            {
              throw ServerBadMessage();
              break;
            }
            case (ST_FAILED):
            {
              throw ServerException();
              break;
            }
            default:
            {
              throw ServerBadMessage();
              break;
            }
          }
        }
        return (this)->decode_ProgramStates(inbound_buf, (&(response_offset)), inbound_bsize);
      }
      uint8_t call_start (std::string req) {
        msgbuf_s = 0;
        (this)->encode_uint32_t(msgbuf, (&(msgbuf_s)), WIRE_VERSION);
        (this)->encode_uint32_t(msgbuf, (&(msgbuf_s)), FNUM_START);
        (this)->encode_progname(msgbuf, (&(msgbuf_s)), req);
        zmq::message_t response;
        (this)->zmq_reqrep((&(response)));
        uint8_t* inbound_buf=((uint8_t*)(((&(response)))->data()));
        uint32_t inbound_bsize=((&(response)))->size();
        uint8_t remote_rcode;
        uint32_t response_offset=0;
        uint32_t wv=(this)->decode_uint32_t(inbound_buf, (&(response_offset)), inbound_bsize);
        if ((wv != WIRE_VERSION)) {
          throw BadMessage();
        }
        remote_rcode = (this)->decode_uint8_t(inbound_buf, (&(response_offset)), inbound_bsize);
        if ((remote_rcode != ST_AFFIRM)) {
          switch (remote_rcode) {
            case (ST_BADMSG):
            {
              throw ServerBadMessage();
              break;
            }
            case (ST_FAILED):
            {
              throw ServerException();
              break;
            }
            default:
            {
              throw ServerBadMessage();
              break;
            }
          }
        }
        return (this)->decode_uint8_t(inbound_buf, (&(response_offset)), inbound_bsize);
      }
      uint8_t call_stop (std::string req) {
        msgbuf_s = 0;
        (this)->encode_uint32_t(msgbuf, (&(msgbuf_s)), WIRE_VERSION);
        (this)->encode_uint32_t(msgbuf, (&(msgbuf_s)), FNUM_STOP);
        (this)->encode_progname(msgbuf, (&(msgbuf_s)), req);
        zmq::message_t response;
        (this)->zmq_reqrep((&(response)));
        uint8_t* inbound_buf=((uint8_t*)(((&(response)))->data()));
        uint32_t inbound_bsize=((&(response)))->size();
        uint8_t remote_rcode;
        uint32_t response_offset=0;
        uint32_t wv=(this)->decode_uint32_t(inbound_buf, (&(response_offset)), inbound_bsize);
        if ((wv != WIRE_VERSION)) {
          throw BadMessage();
        }
        remote_rcode = (this)->decode_uint8_t(inbound_buf, (&(response_offset)), inbound_bsize);
        if ((remote_rcode != ST_AFFIRM)) {
          switch (remote_rcode) {
            case (ST_BADMSG):
            {
              throw ServerBadMessage();
              break;
            }
            case (ST_FAILED):
            {
              throw ServerException();
              break;
            }
            default:
            {
              throw ServerBadMessage();
              break;
            }
          }
        }
        return (this)->decode_uint8_t(inbound_buf, (&(response_offset)), inbound_bsize);
      }
     // members
      bool ctx_created;
      uint8_t msgbuf[33168];
      uint32_t msgbuf_s;
    };
}
#endif