#ifndef GAGGLED_CONTROL_SERVER_H_INCLUDED
#define GAGGLED_CONTROL_SERVER_H_INCLUDED

/* Auto-Generated by RPG. Don't edit this unless you really know what you're up to. No, really. */

#include <stdint.h>
#include <stdexcept>
#include <vector>
#include <string>
#include <zmq.hpp>
#include "rpgbase.hpp"

namespace gaggled_control_server {

    const uint8_t ST_AFFIRM = 0;
    const uint8_t ST_BADMSG = 1;
    const uint8_t ST_FAILED = 2;
    const uint32_t WIRE_VERSION = 5235;
    const uint32_t FNUM_GETSTATE = 1;
    const uint32_t FNUM_START = 2;
    const uint32_t FNUM_STOP = 3;

    class BadMessage : public std::exception {
    public:
     // functions
     // members
    };

    class ProgramStates {
    public:
     // functions
     // members
      std::vector<std::string> down;
      std::vector<std::string> up;
    };

    template<typename implementation_child_type>
    class gaggled_control : public rpgbase::RPGService {
    public:
     // functions
      uint32_t decode_uint32_t (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        uint32_t ret;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          ret = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_uint32_t (uint8_t* outbuf, uint32_t* buf_offset, uint32_t obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((obj >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((obj >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((obj >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
      }
      uint8_t decode_uint8_t (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        uint8_t ret;
        if ((buf_size >= ((*(buf_offset)) + 1))) {
          ret = (((uint8_t)(inbuf[((*(buf_offset)) + 0)])) << 0);
          (*(buf_offset)) = ((*(buf_offset)) + 1);
        } else {
          throw BadMessage();
        }
        return ret;
      }
      void encode_uint8_t (uint8_t* outbuf, uint32_t* buf_offset, uint8_t obj) {
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((obj >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 1);
      }
      std::string decode_progname (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        char vchar_buf[256];
        uint32_t vchar_size;
        std::string ret;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((vchar_size > 255)) {
          throw BadMessage();
        }
        memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
        vchar_buf[vchar_size] = 0;
        ret = std::string(vchar_buf);
        (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
        return ret;
      }
      void encode_progname (uint8_t* outbuf, uint32_t* buf_offset, std::string obj) {
        uint32_t lencache=((&(obj)))->length();
        if ((lencache > 255)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        memcpy(((*(buf_offset)) + outbuf), ((&(obj)))->c_str(), lencache);
        (*(buf_offset)) = ((*(buf_offset)) + lencache);
      }
      ProgramStates decode_ProgramStates (uint8_t* inbuf, uint32_t* buf_offset, uint32_t buf_size) {
        char vchar_buf[256];
        uint32_t vchar_size;
        ProgramStates ret;
        uint32_t blsize;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          blsize = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((blsize > 64)) {
          throw BadMessage();
        }
        for (uint32_t blidx=0; (blidx < blsize); blidx = (blidx + 1)) {
          std::string rd;
          if ((buf_size >= ((*(buf_offset)) + 4))) {
            vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
            (*(buf_offset)) = ((*(buf_offset)) + 4);
          } else {
            throw BadMessage();
          }
          if ((vchar_size > 255)) {
            throw BadMessage();
          }
          memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
          vchar_buf[vchar_size] = 0;
          rd = std::string(vchar_buf);
          (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
          ((&(ret.down)))->push_back(rd);
        }
        uint32_t blsize_1;
        if ((buf_size >= ((*(buf_offset)) + 4))) {
          blsize_1 = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
        } else {
          throw BadMessage();
        }
        if ((blsize_1 > 64)) {
          throw BadMessage();
        }
        for (uint32_t blidx_1=0; (blidx_1 < blsize_1); blidx_1 = (blidx_1 + 1)) {
          std::string rd_1;
          if ((buf_size >= ((*(buf_offset)) + 4))) {
            vchar_size = ((((uint32_t)(inbuf[((*(buf_offset)) + 0)])) << 24) + ((((uint32_t)(inbuf[((*(buf_offset)) + 1)])) << 16) + ((((uint32_t)(inbuf[((*(buf_offset)) + 2)])) << 8) + (((uint32_t)(inbuf[((*(buf_offset)) + 3)])) << 0))));
            (*(buf_offset)) = ((*(buf_offset)) + 4);
          } else {
            throw BadMessage();
          }
          if ((vchar_size > 255)) {
            throw BadMessage();
          }
          memcpy(vchar_buf, ((*(buf_offset)) + inbuf), vchar_size);
          vchar_buf[vchar_size] = 0;
          rd_1 = std::string(vchar_buf);
          (*(buf_offset)) = ((*(buf_offset)) + vchar_size);
          ((&(ret.up)))->push_back(rd_1);
        }
        return ret;
      }
      void encode_ProgramStates (uint8_t* outbuf, uint32_t* buf_offset, ProgramStates& obj) {
        uint32_t listsize=((&(obj.down)))->size();
        if ((listsize > 64)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((listsize >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((listsize >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((listsize >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((listsize >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        for (uint32_t listoffset=0; (listoffset < listsize); listoffset = (listoffset + 1)) {
          uint32_t lencache=((&(obj.down[listoffset])))->length();
          if ((lencache > 255)) {
            throw BadMessage();
          }
          outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache >> 24) & 255)));
          outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache >> 16) & 255)));
          outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache >> 8) & 255)));
          outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache >> 0) & 255)));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
          memcpy(((*(buf_offset)) + outbuf), ((&(obj.down[listoffset])))->c_str(), lencache);
          (*(buf_offset)) = ((*(buf_offset)) + lencache);
        }
        uint32_t listsize_1=((&(obj.up)))->size();
        if ((listsize_1 > 64)) {
          throw BadMessage();
        }
        outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((listsize_1 >> 24) & 255)));
        outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((listsize_1 >> 16) & 255)));
        outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((listsize_1 >> 8) & 255)));
        outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((listsize_1 >> 0) & 255)));
        (*(buf_offset)) = ((*(buf_offset)) + 4);
        for (uint32_t listoffset_1=0; (listoffset_1 < listsize_1); listoffset_1 = (listoffset_1 + 1)) {
          uint32_t lencache_1=((&(obj.up[listoffset_1])))->length();
          if ((lencache_1 > 255)) {
            throw BadMessage();
          }
          outbuf[((*(buf_offset)) + 0)] = ((uint8_t)(((lencache_1 >> 24) & 255)));
          outbuf[((*(buf_offset)) + 1)] = ((uint8_t)(((lencache_1 >> 16) & 255)));
          outbuf[((*(buf_offset)) + 2)] = ((uint8_t)(((lencache_1 >> 8) & 255)));
          outbuf[((*(buf_offset)) + 3)] = ((uint8_t)(((lencache_1 >> 0) & 255)));
          (*(buf_offset)) = ((*(buf_offset)) + 4);
          memcpy(((*(buf_offset)) + outbuf), ((&(obj.up[listoffset_1])))->c_str(), lencache_1);
          (*(buf_offset)) = ((*(buf_offset)) + lencache_1);
        }
      }
      void recv_request (uint8_t* inbuf, uint32_t buf_size, uint8_t* outbuf, uint32_t* buf_offset) {
        uint32_t decode_offset=0;
        uint32_t wv=(this)->decode_uint32_t(inbuf, (&(decode_offset)), buf_size);
        if ((wv != WIRE_VERSION)) {
          throw BadMessage();
        }
        uint32_t fnumber=(this)->decode_uint32_t(inbuf, (&(decode_offset)), buf_size);
        (*(buf_offset)) = 0;
        (this)->encode_uint32_t(outbuf, buf_offset, WIRE_VERSION);
        switch (fnumber) {
          case FNUM_GETSTATE:
          {
            uint8_t request_1;
            try {
              request_1 = (this)->decode_uint8_t(inbuf, (&(decode_offset)), buf_size);
            } catch (...) {
              (this)->encode_uint8_t(outbuf, buf_offset, ST_BADMSG);
              return;
            }
            try {
              ProgramStates response((static_cast<implementation_child_type*>(this))->handle_getstate(request_1));
              (this)->encode_uint8_t(outbuf, buf_offset, ST_AFFIRM);
              (this)->encode_ProgramStates(outbuf, buf_offset, response);
            } catch (...) {
              (*(buf_offset)) = 4;
              (this)->encode_uint8_t(outbuf, buf_offset, ST_FAILED);
            }
            break;
          }
          case FNUM_START:
          {
            std::string request_2;
            try {
              request_2 = (this)->decode_progname(inbuf, (&(decode_offset)), buf_size);
            } catch (...) {
              (this)->encode_uint8_t(outbuf, buf_offset, ST_BADMSG);
              return;
            }
            try {
              uint8_t response=(static_cast<implementation_child_type*>(this))->handle_start(request_2);
              (this)->encode_uint8_t(outbuf, buf_offset, ST_AFFIRM);
              (this)->encode_uint8_t(outbuf, buf_offset, response);
            } catch (...) {
              (*(buf_offset)) = 4;
              (this)->encode_uint8_t(outbuf, buf_offset, ST_FAILED);
            }
            break;
          }
          case FNUM_STOP:
          {
            std::string request_3;
            try {
              request_3 = (this)->decode_progname(inbuf, (&(decode_offset)), buf_size);
            } catch (...) {
              (this)->encode_uint8_t(outbuf, buf_offset, ST_BADMSG);
              return;
            }
            try {
              uint8_t response=(static_cast<implementation_child_type*>(this))->handle_stop(request_3);
              (this)->encode_uint8_t(outbuf, buf_offset, ST_AFFIRM);
              (this)->encode_uint8_t(outbuf, buf_offset, response);
            } catch (...) {
              (*(buf_offset)) = 4;
              (this)->encode_uint8_t(outbuf, buf_offset, ST_FAILED);
            }
            break;
          }
          default:
          {
            (this)->encode_uint8_t(outbuf, buf_offset, ST_BADMSG);
            return;
          }
        }
      }
      ProgramStates handle_getstate (uint8_t req) {
        ProgramStates ret;
        return ret;
      }
      uint8_t handle_start (std::string req) {
        uint8_t ret;
        return ret;
      }
      uint8_t handle_stop (std::string req) {
        uint8_t ret;
        return ret;
      }
      ~gaggled_control () {
        delete sock;
        if (ctx_created) {
          delete ctx;
        }
      }
      gaggled_control (const char* url, uint32_t threads=1, gaggled_control* compatriot=NULL) {
        if ((compatriot == NULL)) {
          ctx = new zmq::context_t(threads);
          ctx_created = true;
        } else {
          ctx = (*(compatriot)).ctx;
          ctx_created = false;
        }
        sock = new zmq::socket_t((*(ctx)), ZMQ_REP);
        (sock)->bind(url);
        pollitem.socket = (*(sock));
        pollitem.events = ZMQ_POLLIN;
      }
      void run_once (long timeout=0) {
        uint32_t busy=0;
        try {
          busy = zmq::poll((&(pollitem)), 1, timeout);
        } catch (zmq::error_t& ze) {
          return;
        }
        if ((busy > 0)) {
          (this)->run_once_bare();
        }
      }
      void run_once_bare () {
        zmq::message_t req;
        (sock)->recv((&(req)));
        (this)->recv_request(((uint8_t*)(((&(req)))->data())), ((&(req)))->size(), ((uint8_t*)(msgbuf)), (&(msgbuf_s)));
        zmq::message_t resp(msgbuf_s);
        memcpy(((&(resp)))->data(), msgbuf, msgbuf_s);
        (sock)->send(resp);
      }
     // members
      bool ctx_created;
      uint8_t msgbuf[33168];
      uint32_t msgbuf_s;
    };
}
#endif